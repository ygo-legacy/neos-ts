import { clear, createStore, del, set, values } from "idb-keyval";
import { proxy } from "valtio";

import { type NeosStore } from "./shared";

const IDB_NAME = "decks";
const deckIdb = createStore(IDB_NAME, IDB_NAME);

export interface IDeck {
  id: string;
  deckName: string;
  main: number[];
  extra: number[];
  side: number[];
}

export const emptyDeck: IDeck = {
  id: "",
  deckName: "",
  main: [],
  extra: [],
  side: [],
};

export const deckStore = proxy({
  decks: [] as IDeck[],

  get(deckName: string) {
    return deckStore.decks.find((deck) => deck.deckName === deckName);
  },

  getById(id: string) {
    return deckStore.decks.find((deck) => deck.id === id);
  },

  async update(deckName: string, deck: IDeck): Promise<boolean> {
    const index = deckStore.decks.findIndex(
      (deck) => deck.deckName === deckName,
    );
    if (index === -1) {
      // if not existed, create one
      await deckStore.add(deck);
      return true;
    } else {
      if (!deck.id) deck.id = deckStore.decks[index].id; // Preserve ID if missing in update payload
      deckStore.decks[index] = deck;
      // 新的名字可能和旧的名字不一样，所以要删除旧的，再添加
      await del(deckName, deckIdb);
      await set(deck.deckName, deck, deckIdb);
      return true;
    }
  },

  async add(deck: IDeck): Promise<boolean> {
    if (deckStore.decks.find((d) => d.deckName === deck.deckName)) return false;
    if (!deck.id) deck.id = crypto.randomUUID();
    deckStore.decks.push(deck);
    await set(deck.deckName, deck, deckIdb);
    return true;
  },

  async delete(deckName: string): Promise<boolean> {
    const index = deckStore.decks.findIndex(
      (deck) => deck.deckName === deckName,
    );
    if (index === -1) return false;
    deckStore.decks.splice(index, 1);
    await del(deckName, deckIdb);
    return true;
  },

  async initialize() {
    const loadedDecks = await values<IDeck>(deckIdb);

    // Migration: Assign IDs to legacy decks
    let migrationNeeded = false;
    for (const deck of loadedDecks) {
      if (!deck.id) {
        deck.id = crypto.randomUUID();
        await set(deck.deckName, deck, deckIdb);
        migrationNeeded = true;
      }
    }
    if (migrationNeeded) {
      console.log("Migrated decks to UUID system");
    }

    deckStore.decks = loadedDecks;

    if (!deckStore.decks.length) {
      // 给玩家预设了几套卡组，一旦idb为空，就会给玩家添加这几套卡组
      const PRESET_DECKS: Record<string, { default: Omit<IDeck, "deckName" | "id"> }> =
        import.meta.glob("/neos-assets/structure-decks/*.ydk", {
          eager: true,
        });
      for (const key in PRESET_DECKS) {
        const deck = PRESET_DECKS[key].default;
        const deckName =
          key.split("/").pop()?.split(".").slice(0, -1).join(".") ??
          "undefined"; // 从路径解析文件名
        // id will be generated by add()
        await deckStore.add({ ...deck, deckName } as IDeck);
      }
    }
  },
  async reset() {
    deckStore.decks = [];
    await clear(deckIdb);
  },
}) satisfies NeosStore;
